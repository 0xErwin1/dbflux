use std::collections::HashMap;
use std::sync::Arc;

use dbflux_core::{ColumnMeta, QueryResult, RowState, Value};
use gpui::TextAlign;

#[derive(Debug, Clone)]
pub struct TableModel {
    pub columns: Vec<ColumnSpec>,
    pub rows: Vec<RowData>,
}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColumnSpec {
    pub id: Arc<str>,
    pub title: Arc<str>,
    pub kind: ColumnKind,
    pub align: TextAlign,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColumnKind {
    Text,
    Integer,
    Float,
    Bool,
    Bytes,
    Json,
    Unknown,
}

#[derive(Debug, Clone)]
pub struct RowData {
    pub cells: Vec<CellValue>,
}

/// Cell values with pre-computed display strings.
/// The display_text is computed once at construction to avoid per-frame allocation.
#[derive(Debug, Clone)]
pub struct CellValue {
    pub kind: CellKind,
    display_text: Arc<str>,
}

#[derive(Debug, Clone)]
pub enum CellKind {
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    Text(Arc<str>),
    Bytes(usize),
    /// Auto-generated value (e.g., `nextval()`, `now()`).
    /// The string is the default expression to display.
    AutoGenerated(Arc<str>),
}

impl TableModel {
    #[allow(dead_code)]
    pub fn new(columns: Vec<ColumnSpec>, rows: Vec<RowData>) -> Self {
        Self { columns, rows }
    }

    #[allow(dead_code)]
    pub fn empty() -> Self {
        Self {
            columns: Vec::new(),
            rows: Vec::new(),
        }
    }

    pub fn row_count(&self) -> usize {
        self.rows.len()
    }

    pub fn col_count(&self) -> usize {
        self.columns.len()
    }

    pub fn cell(&self, row: usize, col: usize) -> Option<&CellValue> {
        self.rows.get(row).and_then(|r| r.cells.get(col))
    }

    /// Update a row with new values from the database (e.g., after RETURNING).
    ///
    /// Returns a new TableModel with the updated row data.
    pub fn with_row_updated(&self, row_idx: usize, values: &[dbflux_core::Value]) -> Self {
        let mut new_rows = self.rows.clone();
        if let Some(row) = new_rows.get_mut(row_idx) {
            row.cells = values.iter().map(CellValue::from).collect();
        }
        Self {
            columns: self.columns.clone(),
            rows: new_rows,
        }
    }
}

impl From<&QueryResult> for TableModel {
    fn from(result: &QueryResult) -> Self {
        let columns = result.columns.iter().map(ColumnSpec::from).collect();

        let rows = result
            .rows
            .iter()
            .map(|row| RowData {
                cells: row.iter().map(CellValue::from).collect(),
            })
            .collect();

        Self { columns, rows }
    }
}

impl From<&ColumnMeta> for ColumnSpec {
    fn from(col: &ColumnMeta) -> Self {
        let kind = infer_column_kind(&col.type_name);
        let align = match kind {
            ColumnKind::Integer | ColumnKind::Float => TextAlign::Right,
            _ => TextAlign::Left,
        };

        Self {
            id: col.name.as_str().into(),
            title: col.name.as_str().into(),
            kind,
            align,
        }
    }
}

fn infer_column_kind(type_name: &str) -> ColumnKind {
    let lower = type_name.to_lowercase();

    if lower.contains("int") || lower.contains("serial") {
        ColumnKind::Integer
    } else if lower.contains("float")
        || lower.contains("double")
        || lower.contains("real")
        || lower.contains("numeric")
        || lower.contains("decimal")
    {
        ColumnKind::Float
    } else if lower.contains("bool") {
        ColumnKind::Bool
    } else if lower.contains("bytea") || lower.contains("blob") || lower.contains("binary") {
        ColumnKind::Bytes
    } else if lower.contains("json") {
        ColumnKind::Json
    } else if lower.contains("text")
        || lower.contains("char")
        || lower.contains("varchar")
        || lower.contains("string")
        || lower.contains("uuid")
        || lower.contains("timestamp")
        || lower.contains("datetime")
        || lower.contains("date")
        || lower.contains("time")
    {
        ColumnKind::Text
    } else {
        ColumnKind::Unknown
    }
}

impl From<&Value> for CellValue {
    fn from(value: &Value) -> Self {
        match value {
            Value::Null => CellValue::null(),
            Value::Bool(b) => CellValue::bool(*b),
            Value::Int(i) => CellValue::int(*i),
            Value::Float(f) => CellValue::float(*f),
            Value::Text(s) => CellValue::text(s.as_str()),
            Value::Bytes(b) => CellValue::bytes(b.len()),
            Value::Json(s) | Value::Decimal(s) => CellValue::text(s.as_str()),
            Value::DateTime(dt) => CellValue::text(&dt.format("%Y-%m-%d %H:%M:%S").to_string()),
            Value::Date(d) => CellValue::text(&d.format("%Y-%m-%d").to_string()),
            Value::Time(t) => CellValue::text(&t.format("%H:%M:%S").to_string()),
        }
    }
}

const MAX_DISPLAY_LEN: usize = 200;

impl CellValue {
    pub fn null() -> Self {
        Self {
            kind: CellKind::Null,
            display_text: "NULL".into(),
        }
    }

    pub fn bool(b: bool) -> Self {
        Self {
            kind: CellKind::Bool(b),
            display_text: if b { "true" } else { "false" }.into(),
        }
    }

    pub fn int(i: i64) -> Self {
        Self {
            kind: CellKind::Int(i),
            display_text: i.to_string().into(),
        }
    }

    pub fn float(f: f64) -> Self {
        let display = if f.fract() == 0.0 && f.abs() < 1e15 {
            format!("{:.1}", f)
        } else {
            f.to_string()
        };
        Self {
            kind: CellKind::Float(f),
            display_text: display.into(),
        }
    }

    pub fn text(s: &str) -> Self {
        let collapsed: String = s
            .chars()
            .map(|c| if c.is_whitespace() { ' ' } else { c })
            .take(MAX_DISPLAY_LEN + 1)
            .collect();

        let display_text = if collapsed.len() > MAX_DISPLAY_LEN || s.len() > MAX_DISPLAY_LEN {
            let truncated: String = collapsed.chars().take(MAX_DISPLAY_LEN).collect();
            format!("{}â€¦", truncated.trim_end()).into()
        } else {
            Arc::from(collapsed.as_str())
        };

        Self {
            kind: CellKind::Text(s.into()),
            display_text,
        }
    }

    pub fn bytes(len: usize) -> Self {
        Self {
            kind: CellKind::Bytes(len),
            display_text: format!("<{} bytes>", len).into(),
        }
    }

    /// Create an auto-generated cell (displays the default expression in gray).
    pub fn auto_generated(expression: &str) -> Self {
        Self {
            kind: CellKind::AutoGenerated(expression.into()),
            display_text: expression.into(),
        }
    }

    /// Returns the pre-computed display text. Cloning Arc<str> is cheap (reference count bump).
    pub fn display_text(&self) -> Arc<str> {
        self.display_text.clone()
    }

    pub fn is_null(&self) -> bool {
        matches!(self.kind, CellKind::Null)
    }

    /// Check if this is an auto-generated value (default expression).
    pub fn is_auto_generated(&self) -> bool {
        matches!(self.kind, CellKind::AutoGenerated(_))
    }

    /// Returns the full text value for editing (not truncated).
    pub fn edit_text(&self) -> String {
        match &self.kind {
            CellKind::Text(s) => s.to_string(),
            CellKind::Int(i) => i.to_string(),
            CellKind::Float(f) => f.to_string(),
            CellKind::Bool(b) => b.to_string(),
            CellKind::Null | CellKind::Bytes(_) | CellKind::AutoGenerated(_) => String::new(),
        }
    }

    /// Check if value needs modal editor (multiline or long text).
    pub fn needs_modal_editor(&self) -> bool {
        match &self.kind {
            CellKind::Text(s) => s.contains('\n') || s.len() > 100,
            _ => false,
        }
    }

    /// Convert CellValue to Value for database operations.
    /// Note: AutoGenerated returns Null so the DB will use its default.
    pub fn to_value(&self) -> Value {
        match &self.kind {
            CellKind::Null => Value::Null,
            CellKind::Bool(b) => Value::Bool(*b),
            CellKind::Int(i) => Value::Int(*i),
            CellKind::Float(f) => Value::Float(*f),
            CellKind::Text(s) => Value::Text(s.to_string()),
            CellKind::Bytes(_) => {
                // Bytes are display-only, can't convert back
                Value::Null
            }
            CellKind::AutoGenerated(_) => {
                // Auto-generated: let DB use its default
                Value::Null
            }
        }
    }
}

/// A pending insert with its data and target visual position.
#[derive(Debug, Clone)]
pub struct PendingInsert {
    /// Cell values for the new row.
    pub data: Vec<CellValue>,
    /// Visual position: insert AFTER this base row index.
    /// If None, insert at the end.
    pub insert_after: Option<usize>,
}

/// Represents what a visual row index maps to.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VisualRowSource {
    /// A row from the base model (index into model.rows).
    Base(usize),
    /// A pending insert (index into pending_inserts).
    Insert(usize),
}

/// Maximum number of undo actions to keep in history.
const MAX_UNDO_HISTORY: usize = 500;

/// An action that can be undone/redone.
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EditAction {
    /// Cell value changed: (row, col, old_value, new_value)
    SetCell {
        row: usize,
        col: usize,
        old_value: Option<CellValue>,
        new_value: CellValue,
    },
    /// Row marked for deletion
    MarkDelete { row: usize },
    /// Row unmarked from deletion
    UnmarkDelete { row: usize },
    /// Pending insert added: (insert_idx, insert_after, data)
    AddInsert {
        insert_idx: usize,
        insert_after: Option<usize>,
        data: Vec<CellValue>,
    },
    /// Pending insert removed: (insert_idx, insert_after, data)
    RemoveInsert {
        insert_idx: usize,
        insert_after: Option<usize>,
        data: Vec<CellValue>,
    },
    /// Pending insert cell modified
    SetInsertCell {
        insert_idx: usize,
        col: usize,
        old_value: CellValue,
        new_value: CellValue,
    },
}

/// Buffer for tracking local edits before committing to the database.
///
/// Acts as an overlay on top of the read-only TableModel. When rendering,
/// cells check the buffer first; if an override exists, it's displayed instead
/// of the base value.
///
/// Also tracks pending inserts (new rows) and pending deletes (rows marked for removal).
#[derive(Debug, Clone, Default)]
pub struct EditBuffer {
    /// Cell overrides: (row_idx, col_idx) -> new value.
    overrides: HashMap<(usize, usize), CellValue>,

    /// State per row (only tracked for rows with changes).
    row_states: HashMap<usize, RowState>,

    /// Pending insert rows with their target positions.
    pending_inserts: Vec<PendingInsert>,

    /// Base row count (from the model). Used to calculate virtual indices.
    base_row_count: usize,

    /// Undo stack: actions that can be undone.
    undo_stack: Vec<EditAction>,

    /// Redo stack: actions that were undone and can be redone.
    redo_stack: Vec<EditAction>,
}

impl EditBuffer {
    pub fn new() -> Self {
        Self::default()
    }

    /// Push an action to the undo stack, enforcing the max history limit.
    fn push_undo(&mut self, action: EditAction) {
        self.undo_stack.push(action);
        // Trim oldest entries if over limit
        if self.undo_stack.len() > MAX_UNDO_HISTORY {
            self.undo_stack.remove(0);
        }
        self.redo_stack.clear();
    }

    /// Get the display value for a cell, checking the buffer first.
    pub fn get_cell<'a>(&'a self, row: usize, col: usize, base: &'a CellValue) -> &'a CellValue {
        self.overrides.get(&(row, col)).unwrap_or(base)
    }

    /// Check if a cell has been modified.
    pub fn is_cell_dirty(&self, row: usize, col: usize) -> bool {
        self.overrides.contains_key(&(row, col))
    }

    /// Set a cell value in the buffer.
    pub fn set_cell(&mut self, row: usize, col: usize, value: CellValue) {
        let old_value = self.overrides.get(&(row, col)).cloned();

        self.push_undo(EditAction::SetCell {
            row,
            col,
            old_value,
            new_value: value.clone(),
        });

        self.overrides.insert((row, col), value);
        self.row_states.insert(row, RowState::Dirty);
    }

    /// Clear all overrides for a specific row.
    pub fn clear_row(&mut self, row: usize) {
        self.overrides.retain(|&(r, _), _| r != row);
        self.row_states.remove(&row);
    }

    /// Clear all overrides.
    pub fn clear_all(&mut self) {
        self.overrides.clear();
        self.row_states.clear();
        self.pending_inserts.clear();
    }

    /// Check if there are any pending changes.
    pub fn has_changes(&self) -> bool {
        !self.overrides.is_empty()
    }

    /// Get the number of dirty rows.
    pub fn dirty_row_count(&self) -> usize {
        self.row_states
            .values()
            .filter(|s| s.is_dirty())
            .count()
    }

    /// Get the state of a row.
    pub fn row_state(&self, row: usize) -> &RowState {
        self.row_states.get(&row).unwrap_or(&RowState::Clean)
    }

    /// Set the state of a row.
    pub fn set_row_state(&mut self, row: usize, state: RowState) {
        if state.is_clean() {
            self.row_states.remove(&row);
        } else {
            self.row_states.insert(row, state);
        }
    }

    /// Get all dirty rows (row indices).
    pub fn dirty_rows(&self) -> Vec<usize> {
        self.row_states
            .iter()
            .filter(|(_, s)| s.is_dirty())
            .map(|(&row, _)| row)
            .collect()
    }

    /// Get all changes for a specific row as (col_idx, CellValue) pairs.
    pub fn row_changes(&self, row: usize) -> Vec<(usize, &CellValue)> {
        self.overrides
            .iter()
            .filter(|&(&(r, _), _)| r == row)
            .map(|(&(_, col), val)| (col, val))
            .collect()
    }

    // === Pending Insert/Delete Operations ===
    //
    // These methods support DBeaver-style buffered operations where inserts and
    // deletes are staged locally until the user explicitly saves.

    /// Set the base row count (from the model).
    /// This is needed to correctly index pending inserts.
    pub fn set_base_row_count(&mut self, count: usize) {
        self.base_row_count = count;
    }

    /// Get the base row count.
    #[allow(dead_code)]
    pub fn base_row_count(&self) -> usize {
        self.base_row_count
    }

    /// Get the total virtual row count (base + pending inserts - pending deletes are still counted).
    #[allow(dead_code)]
    pub fn virtual_row_count(&self) -> usize {
        self.base_row_count + self.pending_inserts.len()
    }

    /// Add a pending insert row at the end.
    /// Returns the index in pending_inserts.
    #[allow(dead_code)]
    pub fn add_pending_insert(&mut self, row_data: Vec<CellValue>) -> usize {
        let idx = self.pending_inserts.len();
        self.pending_inserts.push(PendingInsert {
            data: row_data,
            insert_after: None, // At the end
        });
        idx
    }

    /// Add a pending insert row after a specific base row.
    /// Returns the index in pending_inserts.
    pub fn add_pending_insert_after(&mut self, after_row: usize, row_data: Vec<CellValue>) -> usize {
        let idx = self.pending_inserts.len();

        self.push_undo(EditAction::AddInsert {
            insert_idx: idx,
            insert_after: Some(after_row),
            data: row_data.clone(),
        });

        self.pending_inserts.push(PendingInsert {
            data: row_data,
            insert_after: Some(after_row),
        });
        idx
    }

    /// Check if a row is a pending insert (virtual row).
    #[allow(dead_code)]
    pub fn is_pending_insert(&self, row: usize) -> bool {
        row >= self.base_row_count && row < self.virtual_row_count()
    }

    /// Get pending insert data by its index in pending_inserts array.
    pub fn get_pending_insert_by_idx(&self, insert_idx: usize) -> Option<&Vec<CellValue>> {
        self.pending_inserts.get(insert_idx).map(|pi| &pi.data)
    }

    /// Get mutable pending insert data by its index in pending_inserts array.
    #[allow(dead_code)]
    pub fn get_pending_insert_mut_by_idx(&mut self, insert_idx: usize) -> Option<&mut Vec<CellValue>> {
        self.pending_inserts.get_mut(insert_idx).map(|pi| &mut pi.data)
    }

    /// Compute the visual row ordering that interleaves pending inserts.
    ///
    /// Returns a vector where index = visual row, value = source (base or insert).
    /// Pending inserts are placed AFTER their `insert_after` base row.
    pub fn compute_visual_order(&self) -> Vec<VisualRowSource> {
        let mut result = Vec::with_capacity(self.base_row_count + self.pending_inserts.len());

        // Build list of pending inserts sorted by their target position
        let mut inserts_at: Vec<(usize, usize)> = self
            .pending_inserts
            .iter()
            .enumerate()
            .map(|(idx, pi)| {
                // insert_after = Some(n) means insert after base row n
                // insert_after = None means insert at the end
                let pos = pi.insert_after.unwrap_or(self.base_row_count.saturating_sub(1));
                (pos, idx)
            })
            .collect();

        // Sort by position so we can interleave correctly
        inserts_at.sort_by_key(|(pos, idx)| (*pos, *idx));

        let mut insert_iter = inserts_at.iter().peekable();

        for base_row in 0..self.base_row_count {
            // Add the base row
            result.push(VisualRowSource::Base(base_row));

            // Add any pending inserts that should appear after this base row
            while let Some(&&(after_pos, insert_idx)) = insert_iter.peek() {
                if after_pos == base_row {
                    result.push(VisualRowSource::Insert(insert_idx));
                    insert_iter.next();
                } else {
                    break;
                }
            }
        }

        // Add any remaining inserts (those with insert_after = None or past the end)
        for &(_, insert_idx) in insert_iter {
            result.push(VisualRowSource::Insert(insert_idx));
        }

        result
    }

    /// Map a visual row index to its source.
    /// This is a convenience wrapper that computes the full order and indexes into it.
    /// For performance with large tables, callers should cache compute_visual_order().
    #[allow(dead_code)]
    pub fn visual_row_source(&self, visual_idx: usize) -> Option<VisualRowSource> {
        self.compute_visual_order().get(visual_idx).copied()
    }

    /// Mark an existing row for deletion.
    pub fn mark_for_delete(&mut self, row: usize) {
        if row < self.base_row_count {
            self.push_undo(EditAction::MarkDelete { row });
            self.row_states.insert(row, RowState::PendingDelete);
        }
    }

    /// Unmark a row from deletion.
    #[allow(dead_code)]
    pub fn unmark_delete(&mut self, row: usize) {
        if let Some(state) = self.row_states.get(&row) {
            if state.is_pending_delete() {
                self.push_undo(EditAction::UnmarkDelete { row });
                self.row_states.remove(&row);
            }
        }
    }

    /// Check if a row is marked for deletion.
    #[allow(dead_code)]
    pub fn is_pending_delete(&self, row: usize) -> bool {
        self.row_states
            .get(&row)
            .map(|s| s.is_pending_delete())
            .unwrap_or(false)
    }

    /// Get all rows marked for deletion.
    #[allow(dead_code)]
    pub fn pending_delete_rows(&self) -> Vec<usize> {
        self.row_states
            .iter()
            .filter(|(_, s)| s.is_pending_delete())
            .map(|(&row, _)| row)
            .collect()
    }

    /// Get all pending insert rows with their data.
    pub fn pending_insert_rows(&self) -> Vec<(usize, &Vec<CellValue>)> {
        self.pending_inserts
            .iter()
            .enumerate()
            .map(|(i, insert)| (self.base_row_count + i, &insert.data))
            .collect()
    }

    /// Get a reference to all pending inserts (with position info).
    #[allow(dead_code)]
    pub fn pending_inserts(&self) -> &[PendingInsert] {
        &self.pending_inserts
    }

    /// Check if there are any pending operations (inserts, deletes, or edits).
    #[allow(dead_code)]
    pub fn has_pending_operations(&self) -> bool {
        !self.overrides.is_empty()
            || !self.pending_inserts.is_empty()
            || self.row_states.values().any(|s| s.is_pending_delete())
    }

    /// Remove a pending insert by virtual index.
    /// This shifts subsequent pending insert indices.
    #[allow(dead_code)]
    pub fn remove_pending_insert(&mut self, row: usize) {
        if row >= self.base_row_count {
            let insert_idx = row - self.base_row_count;
            self.remove_pending_insert_by_idx(insert_idx);
        }
    }

    /// Remove a pending insert by its index in the pending_inserts array.
    pub fn remove_pending_insert_by_idx(&mut self, insert_idx: usize) {
        if insert_idx >= self.pending_inserts.len() {
            return;
        }

        // Record action for undo
        let insert = &self.pending_inserts[insert_idx];
        self.push_undo(EditAction::RemoveInsert {
            insert_idx,
            insert_after: insert.insert_after,
            data: insert.data.clone(),
        });

        self.pending_inserts.remove(insert_idx);

        // Note: With visual ordering, we don't track row_states for pending inserts
        // by virtual index anymore, so no need to shift row states.
        // The visual order is recomputed on each render.
    }

    /// Clear pending inserts but keep other edits.
    #[allow(dead_code)]
    pub fn clear_pending_inserts(&mut self) {
        for i in 0..self.pending_inserts.len() {
            let virtual_idx = self.base_row_count + i;
            self.row_states.remove(&virtual_idx);
            // Remove any overrides for this virtual row
            self.overrides.retain(|&(r, _), _| r != virtual_idx);
        }
        self.pending_inserts.clear();
    }

    /// Clear pending deletes but keep other edits.
    #[allow(dead_code)]
    pub fn clear_pending_deletes(&mut self) {
        self.row_states.retain(|_, s| !s.is_pending_delete());
    }

    /// Set a cell value in a pending insert (with undo support).
    pub fn set_insert_cell(&mut self, insert_idx: usize, col: usize, value: CellValue) {
        // Get old value first (before mutable borrow for push_undo)
        let old_value = self
            .pending_inserts
            .get(insert_idx)
            .and_then(|insert| insert.data.get(col).cloned());

        if let Some(old) = old_value {
            self.push_undo(EditAction::SetInsertCell {
                insert_idx,
                col,
                old_value: old,
                new_value: value.clone(),
            });

            if let Some(insert) = self.pending_inserts.get_mut(insert_idx) {
                if col < insert.data.len() {
                    insert.data[col] = value;
                }
            }
        }
    }

    // === Undo/Redo Support ===

    /// Check if there are actions to undo.
    #[allow(dead_code)]
    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    /// Check if there are actions to redo.
    #[allow(dead_code)]
    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }

    /// Undo the last action. Returns true if an action was undone.
    pub fn undo(&mut self) -> bool {
        let Some(action) = self.undo_stack.pop() else {
            return false;
        };

        match action {
            EditAction::SetCell {
                row,
                col,
                old_value,
                new_value,
            } => {
                // Restore old value (or remove if there was none)
                if let Some(old) = old_value.clone() {
                    self.overrides.insert((row, col), old);
                } else {
                    self.overrides.remove(&(row, col));
                    // Check if row still has other changes
                    let has_changes = self.overrides.keys().any(|&(r, _)| r == row);
                    if !has_changes {
                        self.row_states.remove(&row);
                    }
                }
                self.redo_stack.push(EditAction::SetCell {
                    row,
                    col,
                    old_value,
                    new_value,
                });
            }

            EditAction::MarkDelete { row } => {
                self.row_states.remove(&row);
                self.redo_stack.push(EditAction::MarkDelete { row });
            }

            EditAction::UnmarkDelete { row } => {
                self.row_states.insert(row, RowState::PendingDelete);
                self.redo_stack.push(EditAction::UnmarkDelete { row });
            }

            EditAction::AddInsert {
                insert_idx,
                insert_after,
                data,
            } => {
                // Remove the insert that was added
                if insert_idx < self.pending_inserts.len() {
                    self.pending_inserts.remove(insert_idx);
                }
                self.redo_stack.push(EditAction::AddInsert {
                    insert_idx,
                    insert_after,
                    data,
                });
            }

            EditAction::RemoveInsert {
                insert_idx,
                insert_after,
                data,
            } => {
                // Re-add the insert that was removed
                // Insert at the same position if possible
                let insert = PendingInsert {
                    data: data.clone(),
                    insert_after,
                };
                if insert_idx <= self.pending_inserts.len() {
                    self.pending_inserts.insert(insert_idx, insert);
                } else {
                    self.pending_inserts.push(insert);
                }
                self.redo_stack.push(EditAction::RemoveInsert {
                    insert_idx,
                    insert_after,
                    data,
                });
            }

            EditAction::SetInsertCell {
                insert_idx,
                col,
                old_value,
                new_value,
            } => {
                if let Some(insert) = self.pending_inserts.get_mut(insert_idx) {
                    if col < insert.data.len() {
                        insert.data[col] = old_value.clone();
                    }
                }
                self.redo_stack.push(EditAction::SetInsertCell {
                    insert_idx,
                    col,
                    old_value,
                    new_value,
                });
            }
        }

        true
    }

    /// Redo the last undone action. Returns true if an action was redone.
    pub fn redo(&mut self) -> bool {
        let Some(action) = self.redo_stack.pop() else {
            return false;
        };

        match action {
            EditAction::SetCell {
                row,
                col,
                old_value,
                new_value,
            } => {
                self.overrides.insert((row, col), new_value.clone());
                self.row_states.insert(row, RowState::Dirty);
                self.undo_stack.push(EditAction::SetCell {
                    row,
                    col,
                    old_value,
                    new_value,
                });
            }

            EditAction::MarkDelete { row } => {
                self.row_states.insert(row, RowState::PendingDelete);
                self.undo_stack.push(EditAction::MarkDelete { row });
            }

            EditAction::UnmarkDelete { row } => {
                self.row_states.remove(&row);
                self.undo_stack.push(EditAction::UnmarkDelete { row });
            }

            EditAction::AddInsert {
                insert_idx,
                insert_after,
                data,
            } => {
                // Re-add the insert
                let insert = PendingInsert {
                    data: data.clone(),
                    insert_after,
                };
                if insert_idx <= self.pending_inserts.len() {
                    self.pending_inserts.insert(insert_idx, insert);
                } else {
                    self.pending_inserts.push(insert);
                }
                self.undo_stack.push(EditAction::AddInsert {
                    insert_idx,
                    insert_after,
                    data,
                });
            }

            EditAction::RemoveInsert {
                insert_idx,
                insert_after,
                data,
            } => {
                // Remove the insert again
                if insert_idx < self.pending_inserts.len() {
                    self.pending_inserts.remove(insert_idx);
                }
                self.undo_stack.push(EditAction::RemoveInsert {
                    insert_idx,
                    insert_after,
                    data,
                });
            }

            EditAction::SetInsertCell {
                insert_idx,
                col,
                old_value,
                new_value,
            } => {
                if let Some(insert) = self.pending_inserts.get_mut(insert_idx) {
                    if col < insert.data.len() {
                        insert.data[col] = new_value.clone();
                    }
                }
                self.undo_stack.push(EditAction::SetInsertCell {
                    insert_idx,
                    col,
                    old_value,
                    new_value,
                });
            }
        }

        true
    }
}
